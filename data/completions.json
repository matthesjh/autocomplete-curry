[
  {
    "name": "Prelude",
    "types": [
      {
        "name": "Bool"
      },
      {
        "name": "Char"
      },
      {
        "name": "DET",
        "description": "Identity type synonym used to mark deterministic operations."
      },
      {
        "name": "Either"
      },
      {
        "name": "Float"
      },
      {
        "name": "Int"
      },
      {
        "name": "IO"
      },
      {
        "name": "IOError",
        "description": "The (abstract) type of error values. Currently, it distinguishes between general IO errors, user-generated errors (see 'userError'), failures and non-determinism errors during IO computations. These errors can be caught by 'catch' and shown by 'showError'. Each error contains a string shortly explaining the error. This type might be extended in the future to distinguish further error situations."
      },
      {
        "name": "Maybe"
      },
      {
        "name": "Ordering",
        "description": "Ordering type. Useful as a result of comparison functions."
      },
      {
        "name": "String"
      },
      {
        "name": "Success"
      }
    ],
    "constructors": [
      {
        "name": "EQ",
        "typeSig": "Ordering"
      },
      {
        "name": "FailError",
        "typeSig": "String -> IOError"
      },
      {
        "name": "False",
        "typeSig": "Bool"
      },
      {
        "name": "GT",
        "typeSig": "Ordering"
      },
      {
        "name": "IOError",
        "typeSig": "String -> IOError"
      },
      {
        "name": "Just",
        "typeSig": "a -> Maybe a"
      },
      {
        "name": "Left",
        "typeSig": "a -> Either a b"
      },
      {
        "name": "LT",
        "typeSig": "Ordering"
      },
      {
        "name": "NondetError",
        "typeSig": "String -> IOError"
      },
      {
        "name": "Nothing",
        "typeSig": "Maybe a"
      },
      {
        "name": "Right",
        "typeSig": "b -> Either a b"
      },
      {
        "name": "True",
        "typeSig": "Bool"
      },
      {
        "name": "UserError",
        "typeSig": "String -> IOError"
      }
    ],
    "functions": [
      {
        "name": "all",
        "description": "Is a given predicate satisfied by all elements in a list?",
        "typeSig": "(a -> Bool) -> [a] -> Bool"
      },
      {
        "name": "and",
        "description": "Computes the conjunction of a Boolean list.",
        "typeSig": "[Bool] -> Bool"
      },
      {
        "name": "any",
        "description": "Is there an element in a list satisfying a given predicate?",
        "typeSig": "(a -> Bool) -> [a] -> Bool"
      },
      {
        "name": "anyOf",
        "typeSig": "[a] -> a"
      },
      {
        "name": "appendFile",
        "description": "An action that appends a string to a file. It behaves like writeFile if the file does not exist.",
        "typeSig": "String -> String -> IO ()"
      },
      {
        "name": "apply",
        "typeSig": "(a -> b) -> a -> b"
      },
      {
        "name": "break",
        "description": "(break p xs) is equivalent to (takeWhile (not.p) xs, dropWhile (not.p) xs). Thus, it breaks a list at the first occurrence of an element satisfying p.",
        "typeSig": "(a -> Bool) -> [a] -> ([a], [a])"
      },
      {
        "name": "catch",
        "description": "Catches a possible error or failure during the execution of an I/O action. `(catch act errfun)` executes the I/O action `act`. If an exception or failure occurs during this I/O action, the function `errfun` is applied to the error value.",
        "typeSig": "IO a -> (IOError -> IO a) -> IO a"
      },
      {
        "name": "chr",
        "description": "Converts a Unicode value into a character, fails iff the value is out of bounds",
        "typeSig": "Int -> Char"
      },
      {
        "name": "compare",
        "description": "Comparison of arbitrary ground data terms. Data constructors are compared in the order of their definition in the datatype declarations and recursively in the arguments.",
        "typeSig": "a -> a -> Ordering"
      },
      {
        "name": "concat",
        "description": "Concatenates a list of lists into one list.",
        "typeSig": "[[a]] -> [a]"
      },
      {
        "name": "concatMap",
        "description": "Maps a function from elements to lists and merges the result into one list.",
        "typeSig": "(a -> [b]) -> [a] -> [b]"
      },
      {
        "name": "cond",
        "typeSig": "Bool -> a -> a"
      },
      {
        "name": "const",
        "description": "Constant function.",
        "typeSig": "a -> b -> a"
      },
      {
        "name": "curry",
        "description": "Converts an uncurried function to a curried function.",
        "typeSig": "((a, b) -> c) -> a -> b -> c"
      },
      {
        "name": "div",
        "description": "Integer division. The value is the integer quotient of its arguments and always truncated towards negative infinity. Thus, the value of <code>13 `div` 5</code> is <code>2</code>, and the value of <code>-15 `div` 4</code> is <code>-4</code>.",
        "typeSig": "Int -> Int -> Int"
      },
      {
        "name": "divMod",
        "description": "Returns an integer (quotient,remainder) pair. The value is the integer quotient of its arguments and always truncated towards negative infinity.",
        "typeSig": "Int -> Int -> (Int, Int)"
      },
      {
        "name": "done",
        "description": "The empty action that returns nothing.",
        "typeSig": "IO ()"
      },
      {
        "name": "doSolve",
        "description": "Solves a constraint as an I/O action. Note: the constraint should be always solvable in a deterministic way",
        "typeSig": "Bool -> IO ()"
      },
      {
        "name": "drop",
        "description": "Returns suffix without first n elements.",
        "typeSig": "Int -> [a] -> [a]"
      },
      {
        "name": "dropWhile",
        "description": "Returns suffix without takeWhile prefix.",
        "typeSig": "(a -> Bool) -> [a] -> [a]"
      },
      {
        "name": "either",
        "typeSig": "(a -> b) -> (c -> b) -> Either a c -> b"
      },
      {
        "name": "elem",
        "description": "Element of a list?",
        "typeSig": "a -> [a] -> Bool"
      },
      {
        "name": "ensureNotFree",
        "description": "Evaluates the argument to head normal form and returns it. Suspends until the result is bound to a non-variable term.",
        "typeSig": "a -> a"
      },
      {
        "name": "ensureSpine",
        "description": "Evaluates the argument to spine form and returns it. Suspends until the result is bound to a non-variable spine.",
        "typeSig": "[a] -> [a]"
      },
      {
        "name": "enumFrom",
        "description": "Generates an infinite sequence of ascending integers.",
        "typeSig": "Int -> [Int]"
      },
      {
        "name": "enumFromThen",
        "description": "Generates an infinite sequence of integers with a particular in/decrement.",
        "typeSig": "Int -> Int -> [Int]"
      },
      {
        "name": "enumFromThenTo",
        "description": "Generates a sequence of integers with a particular in/decrement.",
        "typeSig": "Int -> Int -> Int -> [Int]"
      },
      {
        "name": "enumFromTo",
        "description": "Generates a sequence of ascending integers.",
        "typeSig": "Int -> Int -> [Int]"
      },
      {
        "name": "error",
        "description": "Aborts the execution with an error message.",
        "typeSig": "String -> a"
      },
      {
        "name": "failed",
        "description": "A non-reducible polymorphic function. It is useful to express a failure in a search branch of the execution. It could be defined by: `failed = head []`",
        "typeSig": "a"
      },
      {
        "name": "filter",
        "description": "Filters all elements satisfying a given predicate in a list.",
        "typeSig": "(a -> Bool) -> [a] -> [a]"
      },
      {
        "name": "flip",
        "description": "(flip f) is identical to f but with the order of arguments reversed.",
        "typeSig": "(a -> b -> c) -> b -> a -> c"
      },
      {
        "name": "foldIO",
        "description": "Folds a list of elements using an binary I/O action and a value for the empty list.",
        "typeSig": "(a -> b -> IO a) -> a -> [b] -> IO a"
      },
      {
        "name": "foldl",
        "description": "Accumulates all list elements by applying a binary operator from left to right. Thus, foldl f z [x1,x2,...,xn] = (...((z `f` x1) `f` x2) ...) `f` xn",
        "typeSig": "(a -> b -> a) -> a -> [b] -> a"
      },
      {
        "name": "foldl1",
        "description": "Accumulates a non-empty list from left to right.",
        "typeSig": "(a -> a -> a) -> [a] -> a"
      },
      {
        "name": "foldr",
        "description": "Accumulates all list elements by applying a binary operator from right to left. Thus, foldr f z [x1,x2,...,xn] = (x1 `f` (x2 `f` ... (xn `f` z)...))",
        "typeSig": "(a -> b -> b) -> b -> [a] -> b"
      },
      {
        "name": "foldr1",
        "description": "Accumulates a non-empty list from right to left:",
        "typeSig": "(a -> a -> a) -> [a] -> a"
      },
      {
        "name": "forIO",
        "description": "Like `mapIO`, but with flipped arguments. This can be useful if the definition of the function is longer than those of the list, like in forIO [1..10] $ \\n -> do ...",
        "typeSig": "[a] -> (a -> IO b) -> IO [b]"
      },
      {
        "name": "forIO_",
        "description": "Like `mapIO_`, but with flipped arguments. This can be useful if the definition of the function is longer than those of the list, like in forIO_ [1..10] $ \\n -> do ...",
        "typeSig": "[a] -> (a -> IO b) -> IO ()"
      },
      {
        "name": "fst",
        "description": "Selects the first component of a pair.",
        "typeSig": "(a, b) -> a"
      },
      {
        "name": "getChar",
        "description": "An action that reads a character from standard output and returns it.",
        "typeSig": "IO Char"
      },
      {
        "name": "getLine",
        "description": "Action to read a line from stdin.",
        "typeSig": "IO String"
      },
      {
        "name": "groundNormalForm",
        "description": "Evaluates the argument to ground normal form and returns it. Suspends as long as the normal form of the argument is not ground.",
        "typeSig": "a -> a"
      },
      {
        "name": "head",
        "description": "Computes the first element of a list.",
        "typeSig": "[a] -> a"
      },
      {
        "name": "id",
        "description": "Identity function.",
        "typeSig": "a -> a"
      },
      {
        "name": "if_then_else",
        "description": "The standard conditional. It suspends if the condition is a free variable.",
        "typeSig": "Bool -> a -> a -> a"
      },
      {
        "name": "ioError",
        "description": "Raises an I/O exception with a given error value.",
        "typeSig": "IOError -> IO a"
      },
      {
        "name": "iterate",
        "description": "Infinite list of repeated applications of a function f to an element x. Thus, `iterate f x = [x, f x, f (f x),...]`",
        "typeSig": "(a -> a) -> a -> [a]"
      },
      {
        "name": "length",
        "description": "Computes the length of a list.",
        "typeSig": "[a] -> Int"
      },
      {
        "name": "liftIO",
        "description": "Apply a pure function to the result of an I/O action.",
        "typeSig": "(a -> b) -> IO a -> IO b"
      },
      {
        "name": "lines",
        "description": "Breaks a string into a list of lines where a line is terminated at a newline character. The resulting lines do not contain newline characters.",
        "typeSig": "String -> [String]"
      },
      {
        "name": "lookup",
        "description": "Looks up a key in an association list.",
        "typeSig": "a -> [(a, b)] -> Maybe b"
      },
      {
        "name": "map",
        "description": "Map a function on all elements of a list.",
        "typeSig": "(a -> b) -> [a] -> [b]"
      },
      {
        "name": "mapIO",
        "description": "Maps an I/O action function on a list of elements. The results of all I/O actions are collected in a list.",
        "typeSig": "(a -> IO b) -> [a] -> IO [b]"
      },
      {
        "name": "mapIO_",
        "description": "Maps an I/O action function on a list of elements. The results of all I/O actions are ignored.",
        "typeSig": "(a -> IO b) -> [a] -> IO ()"
      },
      {
        "name": "max",
        "description": "Maximum of ground data terms.",
        "typeSig": "a -> a -> a"
      },
      {
        "name": "maybe",
        "typeSig": "a -> (b -> a) -> Maybe b -> a"
      },
      {
        "name": "min",
        "description": "Minimum of ground data terms.",
        "typeSig": "a -> a -> a"
      },
      {
        "name": "mod",
        "description": "Integer remainder. The value is the remainder of the integer division and it obeys the rule <code>x `mod` y = x - y * (x `div` y)</code>. Thus, the value of <code>13 `mod` 5</code> is <code>3</code>, and the value of <code>-15 `mod` 4</code> is <code>-3</code>.",
        "typeSig": "Int -> Int -> Int"
      },
      {
        "name": "negate",
        "description": "Unary minus. Usually written as \"- e\".",
        "typeSig": "Int -> Int"
      },
      {
        "name": "negateFloat",
        "description": "Unary minus on Floats. Usually written as \"-e\".",
        "typeSig": "Float -> Float"
      },
      {
        "name": "normalForm",
        "description": "Evaluates the argument to normal form and returns it.",
        "typeSig": "a -> a"
      },
      {
        "name": "not",
        "description": "Negation on Booleans.",
        "typeSig": "Bool -> Bool"
      },
      {
        "name": "notElem",
        "description": "Not element of a list?",
        "typeSig": "a -> [a] -> Bool"
      },
      {
        "name": "null",
        "description": "Is a list empty?",
        "typeSig": "[a] -> Bool"
      },
      {
        "name": "or",
        "description": "Computes the disjunction of a Boolean list.",
        "typeSig": "[Bool] -> Bool"
      },
      {
        "name": "ord",
        "description": "Converts a character into its ASCII value.",
        "typeSig": "Char -> Int"
      },
      {
        "name": "otherwise",
        "description": "Useful name for the last condition in a sequence of conditional equations.",
        "typeSig": "Bool"
      },
      {
        "name": "prim_appendFile",
        "typeSig": "String -> String -> IO ()"
      },
      {
        "name": "prim_chr",
        "typeSig": "Int -> Char"
      },
      {
        "name": "prim_error",
        "typeSig": "String -> a"
      },
      {
        "name": "prim_ioError",
        "typeSig": "IOError -> IO a"
      },
      {
        "name": "prim_ord",
        "typeSig": "Char -> Int"
      },
      {
        "name": "prim_putChar",
        "typeSig": "Char -> IO ()"
      },
      {
        "name": "prim_readFile",
        "typeSig": "String -> IO String"
      },
      {
        "name": "prim_show",
        "typeSig": "a -> String"
      },
      {
        "name": "prim_writeFile",
        "typeSig": "String -> String -> IO ()"
      },
      {
        "name": "print",
        "description": "Converts a term into a string and prints it.",
        "typeSig": "a -> IO ()"
      },
      {
        "name": "putChar",
        "description": "An action that puts its character argument on standard output.",
        "typeSig": "Char -> IO ()"
      },
      {
        "name": "putStr",
        "description": "Action to print a string on stdout.",
        "typeSig": "String -> IO ()"
      },
      {
        "name": "putStrLn",
        "description": "Action to print a string with a newline on stdout.",
        "typeSig": "String -> IO ()"
      },
      {
        "name": "quot",
        "description": "Integer division. The value is the integer quotient of its arguments and always truncated towards zero. Thus, the value of <code>13 `quot` 5</code> is <code>2</code>, and the value of <code>-15 `quot` 4</code> is <code>-3</code>.",
        "typeSig": "Int -> Int -> Int"
      },
      {
        "name": "quotRem",
        "description": "Returns an integer (quotient,remainder) pair. The value is the integer quotient of its arguments and always truncated towards zero.",
        "typeSig": "Int -> Int -> (Int, Int)"
      },
      {
        "name": "readFile",
        "description": "An action that (lazily) reads a file and returns its contents.",
        "typeSig": "String -> IO String"
      },
      {
        "name": "rem",
        "description": "Integer remainder. The value is the remainder of the integer division and it obeys the rule <code>x `rem` y = x - y * (x `quot` y)</code>. Thus, the value of <code>13 `rem` 5</code> is <code>3</code>, and the value of <code>-15 `rem` 4</code> is <code>-3</code>.",
        "typeSig": "Int -> Int -> Int"
      },
      {
        "name": "repeat",
        "description": "Infinite list where all elements have the same value. Thus, `repeat x = [x, x, x,...]`",
        "typeSig": "a -> [a]"
      },
      {
        "name": "replicate",
        "description": "List of length n where all elements have the same value.",
        "typeSig": "Int -> a -> [a]"
      },
      {
        "name": "return",
        "description": "The empty action that directly returns its argument.",
        "typeSig": "a -> IO a"
      },
      {
        "name": "reverse",
        "description": "Reverses the order of all elements in a list.",
        "typeSig": "[a] -> [a]"
      },
      {
        "name": "seq",
        "description": "Evaluates the first argument to head normal form (which could also be a free variable) and returns the second argument.",
        "typeSig": "a -> b -> b"
      },
      {
        "name": "sequenceIO",
        "description": "Executes a sequence of I/O actions and collects all results in a list.",
        "typeSig": "[IO a] -> IO [a]"
      },
      {
        "name": "sequenceIO_",
        "description": "Executes a sequence of I/O actions and ignores the results.",
        "typeSig": "[IO a] -> IO ()"
      },
      {
        "name": "show",
        "description": "Converts an arbitrary term into an external string representation.",
        "typeSig": "a -> String"
      },
      {
        "name": "showError",
        "description": "Shows an error values as a string.",
        "typeSig": "IOError -> String"
      },
      {
        "name": "snd",
        "description": "Selects the second component of a pair.",
        "typeSig": "(a, b) -> b"
      },
      {
        "name": "solve",
        "description": "Enforce a Boolean condition to be true. The computation fails if the argument evaluates to `False`.",
        "typeSig": "Bool -> Bool"
      },
      {
        "name": "span",
        "description": "(span p xs) is equivalent to (takeWhile p xs, dropWhile p xs)",
        "typeSig": "(a -> Bool) -> [a] -> ([a], [a])"
      },
      {
        "name": "splitAt",
        "description": "(splitAt n xs) is equivalent to (take n xs, drop n xs)",
        "typeSig": "Int -> [a] -> ([a], [a])"
      },
      {
        "name": "success",
        "description": "The always satisfiable constraint.",
        "typeSig": "Success"
      },
      {
        "name": "tail",
        "description": "Computes the remaining elements of a list.",
        "typeSig": "[a] -> [a]"
      },
      {
        "name": "take",
        "description": "Returns prefix of length n.",
        "typeSig": "Int -> [a] -> [a]"
      },
      {
        "name": "takeWhile",
        "description": "Returns longest prefix with elements satisfying a predicate.",
        "typeSig": "(a -> Bool) -> [a] -> [a]"
      },
      {
        "name": "uncurry",
        "description": "Converts an curried function to a function on pairs.",
        "typeSig": "(a -> b -> c) -> (a, b) -> c"
      },
      {
        "name": "unknown",
        "description": "Evaluates to a fresh free variable.",
        "typeSig": "a"
      },
      {
        "name": "unless",
        "description": "Performs an `IO` action unless the condition is met.",
        "typeSig": "Bool -> IO () -> IO ()"
      },
      {
        "name": "unlines",
        "description": "Concatenates a list of strings with terminating newlines.",
        "typeSig": "[String] -> String"
      },
      {
        "name": "until",
        "description": "Repeats application of a function until a predicate holds.",
        "typeSig": "(a -> Bool) -> (a -> a) -> a -> a"
      },
      {
        "name": "unwords",
        "description": "Concatenates a list of strings with a blank between two strings.",
        "typeSig": "[String] -> String"
      },
      {
        "name": "unzip",
        "description": "Transforms a list of pairs into a pair of lists.",
        "typeSig": "[(a, b)] -> ([a], [b])"
      },
      {
        "name": "unzip3",
        "description": "Transforms a list of triples into a triple of lists.",
        "typeSig": "[(a, b, c)] -> ([a], [b], [c])"
      },
      {
        "name": "userError",
        "description": "A user error value is created by providing a description of the error situation as a string.",
        "typeSig": "String -> IOError"
      },
      {
        "name": "when",
        "description": "Performs an `IO` action when the condition is met.",
        "typeSig": "Bool -> IO () -> IO ()"
      },
      {
        "name": "words",
        "description": "Breaks a string into a list of words where the words are delimited by white spaces.",
        "typeSig": "String -> [String]"
      },
      {
        "name": "writeFile",
        "description": "An action that writes a file.",
        "typeSig": "String -> String -> IO ()"
      },
      {
        "name": "zip",
        "description": "Joins two lists into one list of pairs. If one input list is shorter than the other, the additional elements of the longer list are discarded.",
        "typeSig": "[a] -> [b] -> [(a, b)]"
      },
      {
        "name": "zip3",
        "description": "Joins three lists into one list of triples. If one input list is shorter than the other, the additional elements of the longer lists are discarded.",
        "typeSig": "[a] -> [b] -> [c] -> [(a, b, c)]"
      },
      {
        "name": "zipWith",
        "description": "Joins two lists into one list by applying a combination function to corresponding pairs of elements. Thus `zip = zipWith (,)`",
        "typeSig": "(a -> b -> c) -> [a] -> [b] -> [c]"
      },
      {
        "name": "zipWith3",
        "description": "Joins three lists into one list by applying a combination function to corresponding triples of elements. Thus `zip3 = zipWith3 (,,)`",
        "typeSig": "(a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]"
      }
    ]
  }
]